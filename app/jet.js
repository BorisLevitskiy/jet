window.jet = (function(){
    var j = {};

    var shortExp = /(\${1,2}(item|index|global|first|last|odd|even)[\w_\.\(\)\[\]]*)/g,//TODO: Make autogenerated
        bracetExpr = /{{([^\}]+)}}/g;
       // longExpRegex =/\$\(([^)]+)\)/g,
        //funcExpRegex = /<\$([^\$]+)\$>/g,
        //escapeRegex = /\\(.)/g,
       // commentRegex = /(\/\*[\w'\s\r\n\*]*\*\/)|(\/\/[\w\s\']*)|(<![\-\-\s\w>\/]*>)/g;

    j.tokens = [
       // { regex: commentRegex, type:"Comment"},
        { regex: bracetExpr, type: "Expression", getExpression: function(matches) { return matches[1]; } },
       { regex:  shortExp, type: "Expression", getExpression: function(matches) {
           console.log('!!', matches);
           return matches[1]; }
       }
       // { regex:  funcExpRegex, type: "Expression" },
       // { regex:  escapeRegex, type: "Escape symbol" }
    ];

    j.specificators = [
        { token: "\\s", translate: " ", description: "Space" },
        { token: "\\t", translate: "\t", description: "Tab" },
        { token: "\\n", translate: "\n", description: "Line end" },
        { token: "", translate: "", description: "Empty string"}
    ];

    j.findSpec = function(spec) {
        var specs = jet.specificators;
        for (var i = 0; i < specs.length; i++) {
            if(specs[i].token === spec) {
                return specs[i];
            }
        }
        return null;
    };

    j.generateTemplate = (function () {

        function generate(items, options) {
            var opts = options;
            opts.template = opts.template || "";
            opts.joinWith = opts.joinWith || "\n";

            console.log("template", opts.template);


            var template = opts.template;

            var output = [];
            var global = {
                items:items,
                foo: function() {
                    return "this is foo";
                }
            };

            for (var i = 0; i < items.length; i++) {
                var item = items[i];

                output.push(generateItemRecord(template));
            }

            var result =  output.join(translateSpecs(opts.joinWith));
            return result; //.replace(/\$\$/g, '$');

            function generateItemRecord(template) {

                var context = {
                        $item: item,
                        $index: i,
                        $first: i == 0,
                        $odd: i % 2 == 1,
                        $even: i % 2 == 0,
                        $last: i == items.length - 1,
                        $global:global
                    };

                _.chain(jet.tokens).where(function(t) {
                    return t.type.toLowerCase() == "expression";
                }).each(function(expr) {
                    var processExpression = _.partial(replaceExpression.bind(context), expr);
                    template = template.replace(expr.regex, processExpression)
                });

                return  template;
                  //  .replace(commentRegex, "")
                    //.replace(bracetExpr, replaceExpression.bind(context));
                    //.replace(longExpRegex, replaceExpression.bind(context))
                   // .replace(funcExpRegex, replaceFuncExpression.bind(context))
                    //.replace(escapeRegex, "$1");
            }

        }

        function replaceExpression(expr, match) {
            var escapeRegex = /^\${2}/; // TODO: Promote to global scope
            if(escapeRegex.test(match)) {
                return match.replace(escapeRegex, '$'); // Escape
            }

            var matches = Array.prototype.slice.call(arguments, 1), // Regex matched group
                value = _.isFunction(expr.getExpression) ? expr.getExpression(matches) : matches[0];

            var result = executeExpression(value, this);
            return result;
        }

        function replaceFuncExpression(match, expr) {

            var funcExpr = "(function(){" + expr + "})()";
            //console.log('execute func expr: %s', funcExpr);
            return executeExpression(funcExpr, this);
        }

        function executeExpression(expression, context) {

            var result = null;

            with(context){
                try {
                    console.log('Executing expression', expression, context);
                    result =  eval(expression);
                }
                catch (error){
                    console.error('Error while executing expression:', expression, error, context);

                    throw new Error('Error while executing expression:\n' + expression + "\n" + error);
                }
            }

            return result;
        }

        return generate;
    })();

    function translateSpecs(input){

        var out = input;
        for (var i = 0; i < j.specificators.length; i++) {
            var spec = j.specificators[i];
            out = out.replace(spec.token, spec.translate);
        }
        return out;
    }

    j.translateSpecs = translateSpecs;

    return j;
})();